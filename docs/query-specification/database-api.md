---
sidebar_label: Database API
sidebar_position: 160
---
# Database API

So far, all the queries and mutations have been specific to the stored and managed developer or user-created objects. However, that is only one aspect of DefraDBs GraphQL API. The other part is the auxiliary APIs, which include MerkleCRDT Traversal, Schema Management, and more.

#### MerkleCRDTs
Internally, all objects in DefraDB are stored in some kind of MerkleCRDT (See DefraDB Tech Specs for more details). These MerkleCRDTs are represented as a series of small updates or `Deltas`, connected in a MerkleDAG. The MerkleDAG is a Merklized version of a DAG (Directed Acyclical Graph), which means each node in the DAG, references a parent node through some kind of Content Identifier (CID). 

![](https://mvpworkshop.co/wp-content/uploads/2021/01/ipfs-inarticle7.jpeg)
*Here is an example structure of a MerkleDAG.*

The `Head` CID represents the "current" or "latest" state of a MerkleDAG.

DefraDB allows users and developers to query, traverse, and validate the DAG structure, allowing for self-verifying data structures.

In the DefraDB Database API, the DAG nodes are represented as `Commit`, `CommitLink`, and `Delta` types. They are defined as follows:

```javascript 
// Commit is an individual node in a CRDTs MerkleDAG
type Commit {
    cid: String            // cid is the Content Identifier of this commit
    height: Int            // height is the incremental version of the current commit
    delta: Delta           // delta is the delta-state update generated by a CRDT mutation 
    previous: [Commit]     // previous is the links to the previous node in the MerkleDAG
    links: [CommitLink]    // links are any additional commits this commit may reference.
}

// CommitLink is a named link to a commit
type CommitLink {
    name: String           // name is the name of the CommitLink
    commit: Commit         // commit is the linked commit
}

// Delta is the differential state change from one node to another
type Delta {
    payload: String        // payload is a base64 encoded byte-array.
}
```

We can query for the latest commit of an object (with id: '123') like so:
```gql
query {
    latestCommit(docid: "123") {
        cid
        height
        delta {
            payload
        }
    }
}
```

We can query for the all the commits of an object (with id: '123') like so:
```gql
query {
    allCommits(docid: "123") {
        cid
        height
        delta {
            payload
        }
    }
}
```

We can query for a specific commit
```gql 
query {
    commit(cid: 'Qm123') {
        cid
        height
        delta {
            payload
        }
    }
}
```

In addition to using the `Commit` specific queries, we can also include some commit version sub-fields in our object queries.

```gql 
query {
    user {
        _key
        name
        age
        
        _version {
            cid
            height
        }
    }
}
```

This example shows how we can query for the additional `_version` field that's generated automatically for each added schema type. The `_version` is the same execution as `latestCommit`.

Both `_version` and `latestCommit` return an array of `Commit` types. This is because the `HEAD` of the MerkleDAG can actually point to more than one DAG node. This is caused by two concurrent updates to the DAG at the same height. More often the DAG will only have a single head, but it's imporant to understand that it *can* have multiple.